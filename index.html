<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>PDF Flow • Smart Layout & Schema Guided</title>

  <!-- ====== External Libraries ====== -->
  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    (function ensurePdfjsReady(){
      const lib = window.pdfjsLib;
      if (!lib) return setTimeout(ensurePdfjsReady, 30);
      lib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";
    })();
  </script>
  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.5/dist/tesseract.min.js"></script>
  <!-- Pako for Compression (Added for BTK Integration) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

  <!-- ====== Styles ====== -->
  <style>
    :root {
      --bg: #0f1115; --panel: #151923; --muted: #232836; --muted-2: #2b3244; 
      --text: #e6e6e6; --text-dim: #9aa3b6; --accent: #62d0ff; 
      --ok: #30d158; --warn: #ffcc00; --err: #ff453a; 
      --line: #1e2431; --shadow: 0 10px 30px rgba(0,0,0,.35);
      --node: #1a2030; --pipe: #2d3346; --pipe-active: #62d0ff;
      --highlight: #ff9f1c;
    }
    [data-theme="light"] {
      --bg: #f0f2f5; --panel: #ffffff; --muted: #dce3eb; --muted-2: #eef2f6;
      --text: #1a202c; --text-dim: #64748b; --accent: #2563eb;
      --ok: #059669; --warn: #d97706; --err: #dc2626;
      --line: #e2e8f0; --shadow: 0 4px 12px rgba(0,0,0,.05);
      --node: #ffffff; --pipe: #cbd5e1; --pipe-active: #2563eb;
      --highlight: #d97706;
    }

    * { box-sizing: border-box; }
    
    body { 
      margin: 0; background: var(--bg); color: var(--text); 
      font-family: system-ui, -apple-system, sans-serif; 
      min-height: 100vh; 
      display: flex; flex-direction: column;
      overflow-y: auto; 
      overflow-x: hidden;
    }
    
    header { 
      height: 56px; background: var(--panel); border-bottom: 1px solid var(--line); 
      display: flex; align-items: center; justify-content: space-between; 
      padding: 0 20px; position: sticky; top: 0; z-index: 100; box-shadow: var(--shadow); 
    }
    h1 { font-size: 16px; font-weight: 700; margin: 0; display: flex; align-items: center; gap: 10px; }
    .badge { background: var(--accent); color: #000; font-size: 11px; padding: 2px 6px; border-radius: 4px; font-weight: 700; }
    
    main { 
      flex: 1; 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); 
      gap: 20px; 
      padding: 20px; 
      max-width: 1600px;
      margin: 0 auto;
      width: 100%;
      position: relative; 
      padding-bottom: 250px; 
    }
    
    .col { display: flex; flex-direction: column; gap: 15px; min-height: 0; z-index: 2; }
    
    .card { background: var(--panel); border: 1px solid var(--muted); border-radius: 12px; padding: 16px; box-shadow: var(--shadow); display: flex; flex-direction: column; gap: 10px; position: relative; transition: border-color 0.3s; }
    .card:hover { border-color: var(--muted-2); }
    .card-head { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--line); padding-bottom: 8px; margin-bottom: 4px; }
    .card-title { font-weight: 600; font-size: 14px; color: var(--accent); }
    
    label { font-size: 12px; font-weight: 600; color: var(--text-dim); display: block; margin-bottom: 4px; }
    input, select, textarea { width: 100%; background: var(--bg); border: 1px solid var(--muted); color: var(--text); padding: 8px; border-radius: 6px; font-family: inherit; font-size: 13px; outline: none; transition: 0.2s; }
    input:focus, select:focus, textarea:focus { border-color: var(--accent); }
    textarea { resize: vertical; min-height: 80px; font-family: monospace; line-height: 1.4; }
    
    .btn-row { display: flex; gap: 8px; margin-top: 4px; }
    button { flex: 1; background: var(--muted-2); border: 1px solid var(--muted); color: var(--text); padding: 8px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 12px; transition: 0.2s; }
    button:hover { border-color: var(--accent); color: var(--accent); }
    button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
    button.primary { background: var(--accent); color: #090b10; border: none; }
    button.primary:hover { filter: brightness(1.1); color: #000; }
    
    .pipes-layer { position: absolute; inset: 0; pointer-events: none; z-index: 1; display: none; }
    @media(min-width: 1100px) { .pipes-layer { display: block; } }
    .pipe { position: absolute; height: 4px; background: var(--pipe); transition: background 0.5s, width 0.5s; border-radius: 2px; }
    .pipe.active { background: var(--pipe-active); box-shadow: 0 0 10px var(--pipe-active); }
    #pipe1 { top: 200px; left: 33%; width: 50px; } 
    #pipe2 { top: 200px; right: 33%; width: 50px; }

    .drop { border: 2px dashed var(--muted); border-radius: 8px; padding: 20px; text-align: center; cursor: pointer; transition: 0.2s; }
    .drop:hover, .drop.drag { border-color: var(--accent); background: rgba(98, 208, 255, 0.05); }
    
    .progress-wrap { height: 4px; background: var(--muted); border-radius: 2px; overflow: hidden; margin-top: 5px; }
    .progress-bar { height: 100%; background: var(--accent); width: 0%; transition: width 0.3s; }
    .status { font-size: 11px; color: var(--text-dim); margin-top: 4px; display: flex; justify-content: space-between; }
    
    .preview-box { background: var(--bg); border: 1px solid var(--muted); border-radius: 6px; padding: 10px; overflow: auto; max-height: 300px; font-family: monospace; font-size: 11px; white-space: pre-wrap; }
    .gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 4px; max-height: 150px; overflow-y: auto; padding: 4px; }
    .thumb { aspect-ratio: 1; background: #000; border-radius: 4px; overflow: hidden; border: 1px solid var(--muted); position: relative; }
    .thumb img { width: 100%; height: 100%; object-fit: contain; }
    .thumb span { position: absolute; bottom: 0; right: 0; background: rgba(0,0,0,0.7); color: #fff; font-size: 9px; padding: 1px 3px; }
    .thumb.skipped { opacity: 0.4; filter: grayscale(1); border: 1px solid var(--err); }

    #logs { position: fixed; bottom: 0; left: 0; right: 0; height: 200px; background: var(--panel); border-top: 1px solid var(--line); z-index: 200; display: flex; flex-direction: column; transition: transform 0.3s; box-shadow: 0 -5px 20px rgba(0,0,0,0.5); }
    #logs.minimized { transform: translateY(165px); }
    .log-head { padding: 8px 20px; background: var(--muted-2); font-size: 12px; font-weight: 700; display: flex; justify-content: space-between; cursor: pointer; }
    .log-body { flex: 1; overflow-y: auto; padding: 10px; font-family: monospace; font-size: 12px; color: var(--text-dim); }
    .log-entry { margin-bottom: 4px; border-bottom: 1px solid var(--line); padding-bottom: 2px; word-break: break-all; }
    .log-entry.ERR { color: var(--err); }
    .log-entry.SUCCESS { color: var(--ok); }
    .log-entry.WARN { color: var(--warn); }
    .log-entry.VERBOSE { color: #555; font-size: 11px; }

    .switch { position: relative; width: 36px; height: 20px; background: var(--muted); border-radius: 20px; cursor: pointer; transition: 0.3s; }
    .switch::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: #fff; border-radius: 50%; transition: 0.3s; }
    .switch.on { background: var(--accent); }
    .switch.on::after { transform: translateX(16px); }

    .hidden { display: none !important; }
    .settings-group { padding: 8px; background: var(--bg); border-radius: 6px; border: 1px solid var(--line); margin-top: 8px; }
    
    .ph-tag { color: var(--highlight); font-weight: bold; border: 1px solid var(--highlight); border-radius: 4px; padding: 0 4px; background: rgba(255, 159, 28, 0.1); }
  </style>
</head>
<body>

<header>
  <h1><span>PDF Flow</span> <span class="badge">Smart Layout</span></h1>
  <div style="display:flex; gap:15px; align-items:center;">
    <div style="font-size:12px; color:var(--text-dim)">Dark Mode</div>
    <div id="themeToggle" class="switch on"></div>
  </div>
</header>

<main>
  <!-- Visual Pipes -->
  <div class="pipes-layer">
    <div id="pipe1" class="pipe"></div>
    <div id="pipe2" class="pipe"></div>
  </div>

  <!-- COLUMN 1: PDF & OCR -->
  <div class="col">
    <div class="card">
      <div class="card-head">
        <span class="card-title">1. Input & Smart Extraction</span>
        <span class="badge">Local / DeepSeek</span>
      </div>
      
      <div id="dropZone" class="drop">
        <strong>Drop PDF Here</strong><br>
        <span style="font-size:11px; color:var(--text-dim)">or click to browse</span>
        <input type="file" id="fileInput" accept="application/pdf" hidden>
      </div>
      
      <div class="settings-group">
        <label>Extraction Method</label>
        <select id="extractMode">
          <option value="local">Local Enhanced (Smart Placement)</option>
          <option value="deepseek">DeepSeek API (Cloud)</option>
        </select>
        
        <div class="btn-row" style="margin-top:8px">
          <div style="flex:1">
            <label>Skip First N Images</label>
            <input type="number" id="skipImages" value="1" min="0">
          </div>
        </div>
      </div>

      <!-- Local Settings -->
      <div id="localSettings" class="settings-group">
        <div style="display:flex; justify-content:space-between; margin-bottom:5px">
          <label style="margin:0">Auto-OCR (Sparse Text)</label>
          <div id="autoOcrToggle" class="switch on"></div>
        </div>
        <div style="display:flex; justify-content:space-between;">
          <label style="margin:0">Table Detection</label>
          <div id="tableDetectToggle" class="switch on"></div>
        </div>
      </div>

      <!-- DeepSeek Settings -->
      <div id="deepseekSettings" class="settings-group hidden">
        <label>API Endpoint</label>
        <input id="ocrEndpoint" type="text" value="https://api.alphaxiv.org/models/v1/deepseek/deepseek-ocr/inference">
        <label style="margin-top:5px">Proxy (Optional)</label>
        <input id="ocrProxy" type="text" placeholder="https://your-proxy.com/...">
      </div>

      <div class="btn-row">
        <button id="btnStep1" class="primary" disabled>Run Extraction</button>
        <button id="btnCancel1" disabled>Cancel</button>
      </div>

      <div>
        <div class="status">
          <span id="status1">Waiting for file...</span>
          <span id="progText1">0%</span>
        </div>
        <div class="progress-wrap"><div id="progBar1" class="progress-bar"></div></div>
      </div>
    </div>

    <!-- Preview Step 1 -->
    <div class="card" style="flex:1">
      <div class="card-head"><span class="card-title">Extracted Assets</span></div>
      <div id="gallery" class="gallery"></div>
      <label style="margin-top:10px">Markdown Output (Placeholders Injected)</label>
      <div id="mdOutput" class="preview-box" style="height:200px"></div>
    </div>
  </div>

  <!-- COLUMN 2: Groq & Schema -->
  <div class="col">
    <div class="card">
      <div class="card-head">
        <span class="card-title">2. Structure Data</span>
        <span class="badge">Groq LLM</span>
      </div>

      <div class="btn-row">
        <div style="flex:1">
          <label>Groq API Key</label>
          <input id="groqKey" type="password" placeholder="gsk_...">
        </div>
      </div>

      <div class="btn-row">
        <div style="flex:1">
          <label>Model</label>
          <select id="groqModel">
            <option value="openai/gpt-oss-120b">openai/gpt-oss-120b</option>
            <option value="llama-3.1-8b-instant">llama-3.1-8b-instant</option>
          </select>
        </div>
        <div style="flex:1">
          <label>CORS Proxy</label>
          <div style="display:flex; align-items:center; height:36px;">
            <div id="corsToggle" class="switch on" title="Use corsproxy.io"></div>
            <span style="font-size:11px; margin-left:8px">Enabled</span>
          </div>
        </div>
      </div>

      <div>
        <label>JSON Schema</label>
        <div style="display:flex; gap:5px">
          <input type="file" id="schemaFile" accept=".json,.txt" style="width:70%">
          <button id="loadDefaultSchema" style="width:30%">Load Default</button>
        </div>
        <textarea id="schemaInput" placeholder="Paste JSON Schema here..." style="margin-top:5px; height:60px"></textarea>
      </div>

      <div>
        <label>Prompt Instruction</label>
        <textarea id="groqPrompt" style="height:120px">Output a json using the text provided while modeling the json according to the json schema provided. That is create a json according to json schema and populate with the text from the text provided. Most text is in chronologial order. !IMPORTATN make sure not to summarize anything !IMPORTANT keep the image placeholder tags in exactly the same form/name and in the same place / order as in the original text compared ot the rest of the json structure !IMPORTANT accuracy is very important</textarea>
      </div>

      <button id="btnStep2" class="primary" style="width:100%" disabled>Run Structuring</button>

      <div>
        <div class="status"><span id="status2">Idle</span></div>
        <div class="progress-wrap"><div id="progBar2" class="progress-bar"></div></div>
      </div>
    </div>

    <!-- Preview Step 2 -->
    <div class="card" style="flex:1">
      <div class="card-head">
        <span class="card-title">Input Preview (To Groq)</span>
        <button style="width:auto; padding:2px 8px; font-size:10px" onclick="togglePreview()">Toggle Output</button>
      </div>
      <div id="groqInputPreview" class="preview-box" style="display:block; border-bottom:1px solid var(--line); margin-bottom:10px; height:150px;"></div>
      
      <div class="card-head">
        <span class="card-title">Groq Output (JSON)</span>
        <div style="display:flex; gap:5px">
          <button class="primary" style="width:auto; padding:2px 8px; font-size:10px" onclick="copyToClip('jsonOutput')">Copy</button>
          <!-- Download LLM JSON button -->
          <button style="width:auto; padding:2px 8px; font-size:10px" id="btnDownloadGroq">Download</button>
        </div>
      </div>
      <div id="jsonOutput" class="preview-box" style="height:150px"></div>
    </div>
  </div>

  <!-- COLUMN 3: Translation & Assembly -->
  <div class="col">
    <!-- STEP 3: Translation (Optional) -->
    <div class="card">
      <div class="card-head">
        <span class="card-title">3. Translation (Optional)</span>
        <span class="badge">DeepL</span>
      </div>

      <div class="btn-row">
        <div style="flex:1">
          <label>DeepL API Key</label>
          <input id="deeplKey" type="password" placeholder="xxxxxxxx:fx">
        </div>
        <div style="flex:1">
          <label>CORS Proxy</label>
          <div style="display:flex; align-items:center; height:36px;">
            <div id="deeplCorsToggle" class="switch on" title="Use corsproxy.io"></div>
            <span style="font-size:11px; margin-left:8px">Enabled</span>
          </div>
        </div>
      </div>

      <div class="btn-row">
        <div style="flex:1">
          <label>Source Language</label>
          <select id="deeplSource">
            <option value="">Auto Detect</option>
            <option value="EN">English (EN)</option>
            <option value="SV">Swedish (SV)</option>
            <option value="DE">German (DE)</option>
            <option value="ES">Spanish (ES)</option>
            <option value="FR">French (FR)</option>
            <option value="IT">Italian (IT)</option>
            <option value="NL">Dutch (NL)</option>
            <option value="PL">Polish (PL)</option>
            <option value="PT">Portuguese (PT)</option>
          </select>
        </div>
        <div style="flex:1">
          <label>Target Language</label>
          <select id="deeplTarget">
            <option value="SV" selected>Swedish (SV)</option>
            <option value="EN">English (EN)</option>
            <option value="DE">German (DE)</option>
            <option value="ES">Spanish (ES)</option>
            <option value="FR">French (FR)</option>
            <option value="IT">Italian (IT)</option>
            <option value="NL">Dutch (NL)</option>
            <option value="PL">Polish (PL)</option>
            <option value="PT">Portuguese (PT)</option>
          </select>
        </div>
      </div>

      <div>
        <label>JSON Source</label>
        <div class="btn-row">
          <button id="btnTransFromGroq">Use Groq Output</button>
          <button id="btnTransUpload">Upload JSON</button>
          <input type="file" id="transFile" accept=".json,.txt,application/json" style="display:none">
        </div>
      </div>

      <div style="margin-top:8px">
        <label>JSON To Translate</label>
        <div id="transInputPreview" class="preview-box" style="height:120px"></div>
      </div>

      <button id="btnTransRun" class="primary" style="width:100%; margin-top:8px">Run Translation</button>

      <div>
        <div class="status"><span id="statusTrans">Idle</span></div>
        <div class="progress-wrap"><div id="progBarTrans" class="progress-bar"></div></div>
      </div>

      <div style="margin-top:8px">
        <div class="card-head" style="padding-left:0; padding-right:0; border-bottom:none; margin-bottom:4px;">
          <span class="card-title">Translated JSON</span>
          <div style="display:flex; gap:5px">
            <button style="width:auto; padding:2px 8px; font-size:10px" id="btnTransCopy">Copy</button>
            <button class="primary" style="width:auto; padding:2px 8px; font-size:10px" id="btnTransDownload">Download</button>
          </div>
        </div>
        <div id="transOutputPreview" class="preview-box" style="height:120px"></div>
      </div>
    </div>

    <!-- STEP 4: Final Assembly -->
    <div class="card">
      <div class="card-head">
        <span class="card-title">4. Final Assembly</span>
        <span class="badge">Image Injection</span>
      </div>

      <div class="btn-row">
        <div style="flex:1">
          <label>Compress Images</label>
          <!-- DEFAULT ON -->
          <div id="compressToggle" class="switch on"></div>
        </div>
        <div style="flex:1">
          <label>Quality (0.1-1.0)</label>
          <!-- DEFAULT 0.8 -->
          <input type="number" id="imgQuality" value="0.8" step="0.1" max="1">
        </div>
      </div>

      <div class="btn-row">
        <div style="flex:1">
          <label>Max Width (px)</label>
          <!-- DEFAULT 1280 -->
          <input type="number" id="imgMaxWidth" value="1280">
        </div>
        <div style="flex:1">
          <label>JSON Display Width</label>
          <input type="number" id="jsonDispWidth" value="400">
        </div>
      </div>

      <button id="btnStep3" class="primary" style="width:100%; margin-top:10px" disabled>Inject Images & Finalize</button>

      <div>
        <div class="status"><span id="status3">Idle</span></div>
        <div class="progress-wrap"><div id="progBar3" class="progress-bar"></div></div>
      </div>
    </div>

    <!-- Preview Step 4 -->
    <div class="card" style="flex:1">
      <div class="card-head">
        <span class="card-title">Final JSON</span>
        <div style="display:flex; gap:5px">
          <button style="width:auto; padding:2px 8px; font-size:10px" onclick="copyToClip('finalJson')">Copy</button>
          <button class="primary" style="width:auto; padding:2px 8px; font-size:10px" id="btnDownload">Download</button>
        </div>
      </div>
      <div id="finalJson" class="preview-box" style="flex:1"></div>
      
      <!-- BTK Integration Buttons -->
      <div style="margin-top:10px; display:flex; gap:8px;">
        <button id="btnOpenBtkLocal" style="background-color:#2d3346; border:1px solid var(--accent); color:var(--accent);">Open in BTK (Local)</button>
        <button id="btnOpenBtkUrl" style="background-color:#2d3346; border:1px solid var(--accent); color:var(--accent);">Open in BTK (URL)</button>
      </div>
    </div>
  </div>
</main>

<!-- Logs Drawer -->
<div id="logs" class="minimized">
  <div class="log-head" onclick="document.getElementById('logs').classList.toggle('minimized')">
    <span>System Logs</span>
    <span>▲ Toggle</span>
  </div>
  <div id="logBody" class="log-body"></div>
</div>

<!-- Hidden Form for Fallback -->
<iframe name="sink" id="sink" style="display:none"></iframe>
<form id="hiddenForm" target="sink" method="POST" enctype="multipart/form-data" style="display:none">
  <input type="file" name="file" id="hiddenInput"/>
</form>

<script>
/**
 * APP STATE & CONFIG
 */
const CONFIG = {
  deepseek: {
    maxAttempts: 5,
    backoffBase: 3000,
    xhrTimeout: 600000, // 10 mins
    formTimeout: 300000 // 5 mins
  },
  phPrefix: '{{IMG:',
  phSuffix: '}}',
  btkUrl: 'https://nomsams.github.io/btk/'
};

const state = {
  file: null,
  assets: [], // { id, page, width, height, blob, url, matrix, yPos }
  markdown: "",
  groqJson: "",
  finalJson: null,
  aborts: { step1: null },
  ocrWorker: null,
  // Translation state
  transInputRaw: "",
  transOutputRaw: "",
  transSourceName: "",
  // JSON used by assembly step (can be Groq output or translated JSON)
  currentJsonForAssembly: ""
};

// UI References
const ui = {
  drop: document.getElementById('dropZone'),
  fileIn: document.getElementById('fileInput'),
  btn1: document.getElementById('btnStep1'),
  btnCancel1: document.getElementById('btnCancel1'),
  gallery: document.getElementById('gallery'),
  mdOut: document.getElementById('mdOutput'),
  skipImages: document.getElementById('skipImages'),
  
  extractMode: document.getElementById('extractMode'),
  localSet: document.getElementById('localSettings'),
  dsSet: document.getElementById('deepseekSettings'),
  
  groqKey: document.getElementById('groqKey'),
  schemaIn: document.getElementById('schemaInput'),
  btn2: document.getElementById('btnStep2'),
  groqInputPreview: document.getElementById('groqInputPreview'),
  jsonOut: document.getElementById('jsonOutput'),
  
  // Translation UI
  deeplKey: document.getElementById('deeplKey'),
  deeplSource: document.getElementById('deeplSource'),
  deeplTarget: document.getElementById('deeplTarget'),
  transInputPreview: document.getElementById('transInputPreview'),
  transOutputPreview: document.getElementById('transOutputPreview'),
  btnTransRun: document.getElementById('btnTransRun'),
  btnTransFromGroq: document.getElementById('btnTransFromGroq'),
  btnTransUpload: document.getElementById('btnTransUpload'),
  transFile: document.getElementById('transFile'),
  btnTransCopy: document.getElementById('btnTransCopy'),
  btnTransDownload: document.getElementById('btnTransDownload'),
  
  // Assembly
  btn3: document.getElementById('btnStep3'),
  finalOut: document.getElementById('finalJson'),
  btnDl: document.getElementById('btnDownload'),
  // Groq JSON download
  btnDlGroq: document.getElementById('btnDownloadGroq'),
  
  // BTK Integration
  btnOpenBtkLocal: document.getElementById('btnOpenBtkLocal'),
  btnOpenBtkUrl: document.getElementById('btnOpenBtkUrl'),
  
  logs: document.getElementById('logBody')
};

/**
 * INITIALIZATION
 */
(async function init() {
  // Load Theme
  const theme = localStorage.getItem('theme') || 'dark';
  setTheme(theme === 'dark');
  document.getElementById('themeToggle').addEventListener('click', () => {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    setTheme(!isDark);
  });

  // Load Keys
  ui.groqKey.value = localStorage.getItem('groqKey') || '';
  ui.groqKey.addEventListener('change', e => localStorage.setItem('groqKey', e.target.value));

  ui.deeplKey.value = localStorage.getItem('deeplKey') || '';
  ui.deeplKey.addEventListener('change', e => localStorage.setItem('deeplKey', e.target.value));

  // Mode Toggle
  ui.extractMode.addEventListener('change', (e) => {
    if(e.target.value === 'local') {
      ui.localSet.classList.remove('hidden');
      ui.dsSet.classList.add('hidden');
    } else {
      ui.localSet.classList.add('hidden');
      ui.dsSet.classList.remove('hidden');
    }
  });

  // Load Schema (Try .txt first, then .json)
  const loadSchema = async () => {
    try {
      log("Attempting to load json-schema.txt...", "VERBOSE");
      let res = await fetch('json-schema.txt');
      if(!res.ok) {
        log("json-schema.txt not found, trying json-schema.json...", "VERBOSE");
        res = await fetch('json-schema.json');
      }
      if(res.ok) {
        ui.schemaIn.value = await res.text();
        log("Loaded schema from file.", "SUCCESS");
      } else {
        log("No default schema found.", "WARN");
      }
    } catch(e) { log("Schema load error: " + e.message, "ERR"); }
  };
  await loadSchema();
  
  document.getElementById('loadDefaultSchema').addEventListener('click', loadSchema);
  document.getElementById('schemaFile').addEventListener('change', async (e) => {
    const f = e.target.files[0];
    if(f) ui.schemaIn.value = await f.text();
  });

  // Toggles
  document.querySelectorAll('.switch').forEach(el => {
    el.addEventListener('click', () => el.classList.toggle('on'));
  });

  log("System Ready. PDF.js Worker: " + pdfjsLib.GlobalWorkerOptions.workerSrc);
})();

function setTheme(isDark) {
  document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
  document.getElementById('themeToggle').classList.toggle('on', isDark);
  localStorage.setItem('theme', isDark ? 'dark' : 'light');
}

function log(msg, type="INFO") {
  const div = document.createElement('div');
  div.className = `log-entry ${type}`;
  div.textContent = `[${new Date().toLocaleTimeString()}] [${type}] ${msg}`;
  ui.logs.appendChild(div);
  ui.logs.scrollTop = ui.logs.scrollHeight;
}

function setProgress(step, pct, text) {
  const bar = document.getElementById(`progBar${step}`);
  const txt = document.getElementById(`progText${step}`);
  const stat = document.getElementById(`status${step}`);
  
  if (bar) bar.style.width = `${pct}%`;
  if (txt) txt.textContent = `${Math.round(pct)}%`;
  if (stat && text) stat.textContent = text;
}

function setTransProgress(pct, text) {
  const bar = document.getElementById('progBarTrans');
  const stat = document.getElementById('statusTrans');
  if (bar) bar.style.width = `${pct}%`;
  if (stat && text) stat.textContent = text;
}

function prettyPrintJson(raw) {
  if (!raw) return '';
  try {
    return JSON.stringify(JSON.parse(raw), null, 2);
  } catch(e) {
    return raw;
  }
}

function highlightPlaceholders(text) {
  if(!text) return '';
  // Escape HTML
  let safe = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  // Highlight
  return safe.replace(/{{IMG:[^}]+}}/g, '<span class="ph-tag">$&</span>');
}

// Helper to extract index from ID "p4_6" -> 6
function getImgIndex(id) {
  const parts = id.split('_');
  if(parts.length > 1) return parseInt(parts[1], 10);
  return 0;
}

/**
 * STEP 1: PDF INPUT & EXTRACTION
 */
ui.drop.addEventListener('click', () => ui.fileIn.click());
ui.drop.addEventListener('dragover', e => { e.preventDefault(); ui.drop.classList.add('drag'); });
ui.drop.addEventListener('dragleave', () => ui.drop.classList.remove('drag'));
ui.drop.addEventListener('drop', e => {
  e.preventDefault(); ui.drop.classList.remove('drag');
  handleFile(e.dataTransfer.files[0]);
});
ui.fileIn.addEventListener('change', e => handleFile(e.target.files[0]));

function handleFile(f) {
  if(!f || f.type !== 'application/pdf') return alert("PDF only");
  state.file = f;
  ui.drop.innerHTML = `<strong>${f.name}</strong><br>${(f.size/1024/1024).toFixed(2)} MB`;
  ui.btn1.disabled = false;
  log(`File selected: ${f.name}`);
}

ui.btn1.addEventListener('click', async () => {
  resetStep1();
  ui.btn1.disabled = true;
  ui.btnCancel1.disabled = false;
  state.aborts.step1 = new AbortController();
  const signal = state.aborts.step1.signal;
  const mode = ui.extractMode.value;
  const skipCount = parseInt(ui.skipImages.value) || 0;

  try {
    // 1. Extract Images
    log("Starting Image Extraction...", "INFO");
    setProgress(1, 5, "Scanning Images...");
    await extractImagesFromPDF(state.file, signal);
    
    // Mark skipped images visually
    const thumbs = document.querySelectorAll('.thumb');
    thumbs.forEach((t, idx) => {
      if(idx < skipCount) t.classList.add('skipped');
    });
    log(`Found ${state.assets.length} images. Skipping first ${skipCount}.`, "VERBOSE");

    let rawText = "";

    if (mode === 'local') {
      // 2a. Local Enhanced Processing (Smart Placement)
      log("Starting Local Layout Analysis...", "INFO");
      setProgress(1, 30, "Analyzing Layout...");
      rawText = await runLocalPDFProcessing(state.file, signal, skipCount);
    } else {
      // 2b. DeepSeek OCR
      log("Starting DeepSeek OCR...", "INFO");
      setProgress(1, 30, "Negotiating OCR...");
      rawText = await runDeepSeekOCR(state.file, signal);
      rawText = injectPlaceholdersSimple(rawText, skipCount);
    }
    
    state.markdown = rawText;
    ui.mdOut.innerHTML = highlightPlaceholders(state.markdown);
    
    setProgress(1, 100, "Extraction Complete");
    log("Step 1 Complete", "SUCCESS");
    
    // Enable Step 2
    ui.btn2.disabled = false;
    document.getElementById('pipe1').classList.add('active');

  } catch (e) {
    if (signal.aborted) log("Step 1 Cancelled", "WARN");
    else log(`Step 1 Failed: ${e.message}`, "ERR");
    setProgress(1, 0, "Failed");
  } finally {
    ui.btn1.disabled = false;
    ui.btnCancel1.disabled = true;
  }
});

ui.btnCancel1.addEventListener('click', () => {
  if(state.aborts.step1) state.aborts.step1.abort();
});

function resetStep1() {
  state.assets = [];
  state.markdown = "";
  ui.gallery.innerHTML = "";
  ui.mdOut.innerHTML = "";
  setProgress(1, 0, "Starting...");
}

// --- PDF.js Image Extraction ---
async function extractImagesFromPDF(file, signal) {
  const buf = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument(buf).promise;
  
  for (let i = 1; i <= pdf.numPages; i++) {
    if(signal.aborted) throw new Error("Aborted");
    setProgress(1, 5 + (i/pdf.numPages)*20, `Scanning Images P${i}...`);
    
    const page = await pdf.getPage(i);
    const ops = await page.getOperatorList();
    const viewport = page.getViewport({scale: 1.0}); 
    
    let m = [1, 0, 0, 1, 0, 0];
    const stack = [];
    const multiply = (m1, m2) => [
      m1[0]*m2[0] + m1[2]*m2[1],
      m1[1]*m2[0] + m1[3]*m2[1],
      m1[0]*m2[2] + m1[2]*m2[3],
      m1[1]*m2[2] + m1[3]*m2[3],
      m1[0]*m2[4] + m1[2]*m2[5] + m1[4],
      m1[1]*m2[4] + m1[3]*m2[5] + m1[5]
    ];

    for (let j = 0; j < ops.fnArray.length; j++) {
      const fn = ops.fnArray[j];
      const args = ops.argsArray[j];

      if (fn === pdfjsLib.OPS.save) stack.push([...m]);
      else if (fn === pdfjsLib.OPS.restore) { if(stack.length) m = stack.pop(); }
      else if (fn === pdfjsLib.OPS.transform) m = multiply(m, args);
      else if (fn === pdfjsLib.OPS.paintImageXObject || fn === pdfjsLib.OPS.paintInlineImageXObject) {
        const imgName = args[0];
        let imgObj;
        try {
          if(page.objs.has(imgName)) imgObj = page.objs.get(imgName);
          else if(page.commonObjs.has(imgName)) imgObj = page.commonObjs.get(imgName);
        } catch(e) { continue; }

        if(imgObj) {
          const pdfX = m[2] + m[4]; 
          const pdfY = m[3] + m[5]; 
          const pt = viewport.convertToViewportPoint(pdfX, pdfY);
          const yPos = pt[1]; 
          
          await processImage(imgObj, i, m, yPos);
        }
      }
    }
  }
}

async function processImage(imgObj, pageNum, matrix, yPos) {
  if(imgObj.width < 50 || imgObj.height < 50) return; 

  const canvas = document.createElement('canvas');
  canvas.width = imgObj.width;
  canvas.height = imgObj.height;
  const ctx = canvas.getContext('2d');

  if(imgObj.bitmap) {
    ctx.drawImage(imgObj.bitmap, 0, 0);
  } else if(imgObj.data) {
    const imgData = ctx.createImageData(imgObj.width, imgObj.height);
    const data = imgObj.data;
    let j=0, len=data.length;
    if(len === imgObj.width*imgObj.height*4) imgData.data.set(data);
    else if(len === imgObj.width*imgObj.height*3) {
      for(let i=0; i<len; i+=3) {
        imgData.data[j++] = data[i]; imgData.data[j++] = data[i+1]; imgData.data[j++] = data[i+2]; imgData.data[j++] = 255;
      }
    } else {
      for(let i=0; i<len; i++) {
        imgData.data[j++] = data[i]; imgData.data[j++] = data[i]; imgData.data[j++] = data[i]; imgData.data[j++] = 255;
      }
    }
    ctx.putImageData(imgData, 0, 0);
  } else return;

  const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
  const url = URL.createObjectURL(blob);
  const id = `p${pageNum}_${state.assets.length+1}`;
  
  state.assets.push({ id, page: pageNum, width: imgObj.width, height: imgObj.height, blob, url, yPos });
  
  const div = document.createElement('div');
  div.className = 'thumb';
  div.innerHTML = `<img src="${url}"><span>${id}</span>`;
  ui.gallery.appendChild(div);
}

// --- LOCAL PDF PROCESSING (Smart Placement) ---
async function runLocalPDFProcessing(file, signal, skipCount) {
  const buf = await file.arrayBuffer();
  const doc = await pdfjsLib.getDocument(buf).promise;
  const total = doc.numPages;
  let fullMarkdown = "";

  const autoOcr = document.getElementById('autoOcrToggle').classList.contains('on');
  const tableDetect = document.getElementById('tableDetectToggle').classList.contains('on');

  // Filter assets based on skip count AND sort strictly by ID index to ensure correct order
  const validAssets = state.assets.slice(skipCount).sort((a,b) => getImgIndex(a.id) - getImgIndex(b.id));

  for(let i=1; i<=total; i++){
    if(signal.aborted) throw new Error("Aborted");
    setProgress(1, 30 + (i/total)*60, `Processing Text P${i}...`);
    
    const page = await doc.getPage(i);
    const viewport = page.getViewport({ scale: 1.0 });
    let pageMd = "";
    
    // 1. Get Text Content
    const textContent = await page.getTextContent({ normalizeWhitespace:true });
    const sparse = isTextSparse(textContent);
    
    if(sparse && autoOcr) {
      log(`Page ${i}: Sparse text. Running Tesseract...`, "WARN");
      const canvas = await renderPageToCanvas(page, 2.0);
      pageMd = await ocrCanvas(canvas);
      // Append images at bottom for OCR pages (no coord info)
      const pageImages = validAssets.filter(a => a.page === i);
      
      if(pageImages.length) {
        pageMd += "\n\n";
        pageImages.forEach(img => pageMd += `\n${CONFIG.phPrefix}${img.id}|W:${img.width}|H:${img.height}${CONFIG.phSuffix}`);
      }
    } else {
      // Smart Interleaving
      const pageImages = validAssets.filter(a => a.page === i);
      pageMd = mergeImagesIntoMarkdown(textContent, pageImages, viewport, { tableDetect, mergeHyphens: true });
    }

    fullMarkdown += (pageMd ? pageMd + "\n\n" : "") + "---\n\n";
  }

  return fullMarkdown.trim();
}

// --- Smart Interleaving Algorithm ---
function mergeImagesIntoMarkdown(textContent, images, viewport, opts) {
  // 1. Convert Text Items to Viewport Coordinates (Top-Left Origin)
  const items = textContent.items.map(it => {
    const tx = it.transform[4];
    const ty = it.transform[5] + it.height; 
    const pt = viewport.convertToViewportPoint(tx, ty);
    return {
      str: it.str,
      x: pt[0],
      y: pt[1], // Visual Top Y
      h: it.height,
      w: it.width,
      fs: Math.sqrt(Math.abs(it.transform[0]*it.transform[3])),
      hasEOL: it.hasEOL
    };
  });

  // 2. Sort Text by Y (Top to Bottom)
  items.sort((a,b) => a.y - b.y || a.x - b.x);

  // 3. Group Text into Paragraphs/Blocks
  const blocks = [];
  let curBlock = { yStart: 0, yEnd: 0, items: [] };
  
  if(items.length > 0) {
    curBlock.yStart = items[0].y;
    curBlock.items.push(items[0]);
    curBlock.yEnd = items[0].y;
  }

  for(let i=1; i<items.length; i++) {
    const it = items[i];
    const prev = items[i-1];
    // New block if vertical gap is large (> 20px)
    if(Math.abs(it.y - prev.y) > 20) {
      blocks.push(curBlock);
      curBlock = { yStart: it.y, yEnd: it.y, items: [it] };
    } else {
      curBlock.items.push(it);
      curBlock.yEnd = Math.max(curBlock.yEnd, it.y);
    }
  }
  if(curBlock.items.length) blocks.push(curBlock);

  // 4. Interleave Images and Blocks
  const combined = [];
  blocks.forEach(b => combined.push({ type: 'text', y: b.yStart, data: b }));
  
  // Images are already sorted by ID in runLocalPDFProcessing, but we need to merge them
  images.forEach(img => combined.push({ type: 'image', y: img.yPos, data: img }));

  // 5. Sort Combined List
  // Prioritize ID order for images relative to each other
  combined.sort((a,b) => {
    if (a.type === 'image' && b.type === 'image') {
      return getImgIndex(a.data.id) - getImgIndex(b.data.id);
    }
    if (Math.abs(a.y - b.y) > 15) {
      return a.y - b.y;
    }
    return 0; 
  });

  // 6. Generate Markdown
  let md = "";
  combined.forEach(node => {
    if(node.type === 'image') {
      md += `\n\n${CONFIG.phPrefix}${node.data.id}|W:${node.data.width}|H:${node.data.height}${CONFIG.phSuffix}\n\n`;
    } else {
      const blockText = simpleBlockToText(node.data.items);
      md += blockText + "\n\n";
    }
  });

  return md.trim();
}

function simpleBlockToText(items) {
  // Simple line grouping within block
  let lines = [];
  let curLine = [];
  items.forEach(it => {
    if(curLine.length === 0) { curLine.push(it); return; }
    const last = curLine[curLine.length-1];
    if(Math.abs(it.y - last.y) < 5) curLine.push(it);
    else { lines.push(curLine); curLine = [it]; }
  });
  if(curLine.length) lines.push(curLine);

  return lines.map(line => {
    line.sort((a,b) => a.x - b.x);
    return line.map(l => l.str).join(" ");
  }).join("\n");
}

// --- Helpers ---
function isTextSparse(textContent){
  const items = textContent.items || [];
  const totalChars = items.reduce((p,c)=>p + (c.str?.length||0), 0);
  return items.length < 8 || totalChars < 40;
}

async function renderPageToCanvas(page, scale){
  const viewport = page.getViewport({ scale });
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently:true });
  canvas.width = Math.ceil(viewport.width);
  canvas.height = Math.ceil(viewport.height);
  await page.render({ canvasContext: ctx, viewport }).promise;
  return canvas;
}

async function ensureOCRWorker(){
  if(state.ocrWorker) return state.ocrWorker;
  log("Initializing Tesseract Worker...", "VERBOSE");
  state.ocrWorker = await Tesseract.createWorker('eng');
  return state.ocrWorker;
}

async function ocrCanvas(canvas){
  const worker = await ensureOCRWorker();
  const res = await worker.recognize(canvas);
  return res.data.text;
}

// --- DEEPSEEK OCR LOGIC ---
async function runDeepSeekOCR(file, signal) {
  const endpoint = document.getElementById('ocrEndpoint').value;
  const customProxy = document.getElementById('ocrProxy').value;
  
  const candidates = [
    { name: 'CorsProxy.io', url: `https://corsproxy.io/?${encodeURIComponent(endpoint)}`, type: 'xhr' },
    { name: 'Proxy.Cors.sh', url: `https://proxy.cors.sh/${endpoint}`, type: 'xhr' },
    { name: 'Direct', url: endpoint, type: 'xhr' },
    { name: 'Form Fallback', url: `https://corsproxy.io/?${encodeURIComponent(endpoint)}`, type: 'form' }
  ];
  if(customProxy) candidates.unshift({ name: 'Custom', url: customProxy, type: 'xhr' });

  const promises = candidates.map((c, i) => {
    return new Promise(async (resolve, reject) => {
      await new Promise(r => setTimeout(r, i * 2000));
      if(signal.aborted) return reject();
      
      for(let attempt=1; attempt <= CONFIG.deepseek.maxAttempts; attempt++) {
        if(signal.aborted) return reject();
        log(`Trying ${c.name} (Attempt ${attempt})...`, "VERBOSE");
        try {
          const txt = c.type === 'xhr' 
            ? await tryXHR(c.url, file, signal) 
            : await tryForm(c.url, file);
          if(txt) {
            log(`Winner: ${c.name}`, "SUCCESS");
            resolve(txt);
            return;
          }
        } catch(e) {}
        await new Promise(r => setTimeout(r, CONFIG.deepseek.backoffBase));
      }
      reject();
    });
  });

  return Promise.any(promises);
}

function tryXHR(url, file, signal) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('POST', url, true);
    xhr.timeout = CONFIG.deepseek.xhrTimeout;
    xhr.withCredentials = false;
    const fd = new FormData();
    fd.append('file', file);
    xhr.onload = () => {
      if(xhr.status >= 200 && xhr.status < 300) {
        const txt = parseDeepSeekResponse(xhr.responseText);
        if(txt) resolve(txt); else reject();
      } else reject();
    };
    xhr.onerror = reject;
    xhr.ontimeout = reject;
    if(signal) signal.addEventListener('abort', () => xhr.abort());
    xhr.send(fd);
  });
}

function tryForm(url, file) {
  return new Promise((resolve, reject) => {
    const form = document.getElementById('hiddenForm');
    const input = document.getElementById('hiddenInput');
    const iframe = document.getElementById('sink');
    form.action = url;
    const dt = new DataTransfer();
    dt.items.add(file);
    input.files = dt.files;
    let done = false;
    const t = setTimeout(() => { done=true; reject(); }, CONFIG.deepseek.formTimeout);
    iframe.onload = () => {
      if(done) return;
      done = true; clearTimeout(t);
      try {
        const txt = parseDeepSeekResponse(iframe.contentDocument.body.textContent);
        if(txt) resolve(txt); else reject();
      } catch(e) { reject(); }
    };
    form.submit();
  });
}

function parseDeepSeekResponse(raw) {
  try {
    const json = JSON.parse(raw);
    const findStr = (o) => {
      if(typeof o === 'string') return o;
      if(typeof o !== 'object' || !o) return '';
      let max = '';
      for(let k in o) {
        let s = findStr(o[k]);
        if(s.length > max.length) max = s;
      }
      return max;
    };
    return findStr(json);
  } catch(e) { return raw.length > 50 ? raw : null; }
}

function injectPlaceholdersSimple(text, skipCount) {
  // Sort strictly by ID index for DeepSeek mode
  const assets = state.assets.slice(skipCount).sort((a,b) => getImgIndex(a.id) - getImgIndex(b.id));
  let output = text + "\n\n";
  let curPage = -1;
  assets.forEach(a => {
    if(a.page !== curPage) {
      output += `\n<!-- Page ${a.page} Images -->\n`;
      curPage = a.page;
    }
    output += `\n${CONFIG.phPrefix}${a.id}|W:${a.width}|H:${a.height}${CONFIG.phSuffix}`;
  });
  return output;
}

/**
 * STEP 2: GROQ STRUCTURING
 */
function cleanJson(str) {
  // Remove markdown code blocks to prevent syntax errors
  if (!str) return "";
  return str.replace(/```json/g, '').replace(/```/g, '').trim();
}

ui.btn2.addEventListener('click', async () => {
  const key = ui.groqKey.value;
  const schema = ui.schemaIn.value;
  if(!key) return alert("API Key required");
  if(!schema) return alert("Schema required");

  ui.btn2.disabled = true;
  setProgress(2, 10, "Preparing Request...");
  
  const model = document.getElementById('groqModel').value;
  const useProxy = document.getElementById('corsToggle').classList.contains('on');
  const prompt = document.getElementById('groqPrompt').value;

  const messages = [
    { role: "system", content: "You are a data extraction assistant. Output valid JSON only." },
    { role: "user", content: `JSON Schema:\n${schema}` },
    { role: "user", content: `Text with Image Placeholders:\n${state.markdown}` },
    { role: "user", content: prompt }
  ];

  // Show Input Preview
  ui.groqInputPreview.innerHTML = highlightPlaceholders(messages[2].content);

  try {
    log("Sending to Groq...", "INFO");
    setProgress(2, 40, "Waiting for LLM...");
    
    let url = "https://api.groq.com/openai/v1/chat/completions";
    if(useProxy) url = "https://corsproxy.io/?" + encodeURIComponent(url);

    const res = await fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${key}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: model,
        messages: messages,
        temperature: 0.2,
        max_completion_tokens: 8192,
        response_format: { type: "json_object" }
      })
    });

    if(!res.ok) throw new Error(`Groq API Error: ${res.status}`);
    
    const data = await res.json();
    let content = data.choices[0].message.content;
    
    // Clean JSON before storing
    content = cleanJson(content);
    
    // Keep the raw JSON string as returned by the LLM
    state.groqJson = content;
    // Default JSON for assembly is the Groq output (can be overridden by translation)
    state.currentJsonForAssembly = content;
    // Also pre-populate translation input for convenience
    state.transInputRaw = content;
    state.transSourceName = state.file && state.file.name
      ? state.file.name.replace(/\.pdf$/i, "") + " structured"
      : "structured";

    // Pretty-print JSON for display
    ui.jsonOut.textContent = prettyPrintJson(content);
    if (ui.transInputPreview) {
      ui.transInputPreview.textContent = prettyPrintJson(content);
    }
    
    setProgress(2, 100, "Structuring Complete");
    log("Step 2 Complete", "SUCCESS");
    
    ui.btn3.disabled = false;
    document.getElementById('pipe2').classList.add('active');

  } catch(e) {
    log(e.message, "ERR");
    setProgress(2, 0, "Failed");
  } finally {
    ui.btn2.disabled = false;
  }
});

function togglePreview() {
  const p = ui.groqInputPreview;
  p.style.display = p.style.display === 'none' ? 'block' : 'none';
}

/**
 * STEP 3: TRANSLATION (OPTIONAL, DEEPL)
 */

// Helpers to decide what to translate
function shouldTranslateString(str) {
  if (!str) return false;
  const trimmed = str.trim();
  if (!trimmed) return false;
  if (trimmed.length < 2) return false;
  if (trimmed.startsWith(CONFIG.phPrefix) && trimmed.endsWith(CONFIG.phSuffix)) return false;
  if (/^data:image\//i.test(trimmed)) return false;
  if (/^https?:\/\//i.test(trimmed)) return false;
  if (/^[\d\s.,:/+\-–()]+$/.test(trimmed)) return false;
  return true;
}

function containsImgPlaceholder(str) {
  return typeof str === 'string' && str.includes(CONFIG.phPrefix);
}

function splitByPlaceholders(str) {
  const regex = new RegExp(`(${CONFIG.phPrefix}[^}]+${CONFIG.phSuffix})`, 'g');
  const parts = str.split(regex);
  return parts
    .filter(p => p.length > 0)
    .map(p => {
      if (p.startsWith(CONFIG.phPrefix) && p.endsWith(CONFIG.phSuffix)) {
        return { type: 'placeholder', value: p };
      }
      return { type: 'text', value: p };
    });
}

// Collect unique text segments to translate (token-efficient, placeholder-safe)
function collectTextSegments(node, segmentMap) {
  if (node == null) return;
  if (typeof node === 'string') {
    if (containsImgPlaceholder(node)) {
      const segs = splitByPlaceholders(node);
      segs.forEach(seg => {
        if (seg.type === 'text' && shouldTranslateString(seg.value) && !segmentMap.has(seg.value)) {
          segmentMap.set(seg.value, null);
        }
      });
    } else if (shouldTranslateString(node) && !segmentMap.has(node)) {
      segmentMap.set(node, null);
    }
  } else if (Array.isArray(node)) {
    node.forEach(child => collectTextSegments(child, segmentMap));
  } else if (typeof node === 'object') {
    for (const key in node) {
      if (Object.prototype.hasOwnProperty.call(node, key)) {
        collectTextSegments(node[key], segmentMap);
      }
    }
  }
}

// Apply translations back into JSON structure
function applySegmentTranslations(node, segmentMap) {
  if (node == null) return node;
  if (typeof node === 'string') {
    if (containsImgPlaceholder(node)) {
      const segs = splitByPlaceholders(node);
      const rebuilt = segs.map(seg => {
        if (seg.type === 'text' && segmentMap.has(seg.value)) {
          return segmentMap.get(seg.value);
        }
        return seg.value;
      }).join('');
      return rebuilt;
    } else if (segmentMap.has(node)) {
      return segmentMap.get(node);
    }
    return node;
  } else if (Array.isArray(node)) {
    return node.map(child => applySegmentTranslations(child, segmentMap));
  } else if (typeof node === 'object') {
    const out = {};
    for (const key in node) {
      if (Object.prototype.hasOwnProperty.call(node, key)) {
        out[key] = applySegmentTranslations(node[key], segmentMap);
      }
    }
    return out;
  }
  return node;
}

// DeepL call
async function translateSegmentsWithDeepL(key, segments, sourceLang, targetLang, useProxy) {
  if (!segments.length) return [];
  const params = new URLSearchParams();
  params.append('auth_key', key);
  segments.forEach(t => params.append('text', t));
  params.append('target_lang', targetLang || 'SV');
  if (sourceLang) params.append('source_lang', sourceLang);

  let url = 'https://api-free.deepl.com/v2/translate';
  if (useProxy) {
    url = 'https://corsproxy.io/?' + encodeURIComponent(url);
  }

  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params.toString()
  });

  if (!res.ok) {
    throw new Error('DeepL API error: ' + res.status);
  }

  const data = await res.json();
  if (!data.translations || !Array.isArray(data.translations)) {
    throw new Error('DeepL response missing translations');
  }

  return data.translations.map(t => t.text);
}

// Translation UI wiring
ui.btnTransFromGroq.addEventListener('click', () => {
  if (!state.groqJson) {
    alert("No Groq output available yet. Run Step 2 first.");
    return;
  }
  state.transInputRaw = state.groqJson;
  ui.transInputPreview.textContent = prettyPrintJson(state.groqJson);
  state.transSourceName = state.file && state.file.name
    ? state.file.name.replace(/\.pdf$/i, "") + " structured"
    : "structured";
  log("Loaded JSON for translation from Groq output.", "INFO");
});

ui.btnTransUpload.addEventListener('click', () => {
  ui.transFile.click();
});

ui.transFile.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  const txt = await f.text();
  state.transInputRaw = txt;
  ui.transInputPreview.textContent = prettyPrintJson(txt);
  state.transSourceName = f.name.replace(/\.[^.]+$/,'');
  log("Loaded JSON for translation from file: " + f.name, "INFO");
});

ui.btnTransRun.addEventListener('click', runTranslation);

ui.btnTransCopy.addEventListener('click', () => {
  const txt = ui.transOutputPreview.textContent;
  if (!txt) return;
  navigator.clipboard.writeText(txt);
  log("Copied translated JSON to clipboard", "INFO");
});

ui.btnTransDownload.addEventListener('click', () => {
  if (!state.transOutputRaw) return;
  const blob = new Blob([state.transOutputRaw], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  let base = state.transSourceName || (state.file && state.file.name
    ? state.file.name.replace(/\.pdf$/i, "")
    : "translated");
  a.download = `${base} translated.json`;
  a.click();
});

async function runTranslation() {
  const key = ui.deeplKey.value.trim();
  if (!key) {
    alert("DeepL API key required");
    return;
  }

  // Prefer explicit translation input; fall back to Groq JSON
  const raw = state.transInputRaw || state.groqJson;
  if (!raw) {
    alert("No JSON to translate. Load JSON from Groq or upload a JSON file.");
    return;
  }

  try {
    ui.btnTransRun.disabled = true;
    setTransProgress(5, "Parsing JSON...");
    let obj;
    try {
      obj = JSON.parse(raw);
    } catch(e) {
      alert("Input is not valid JSON: " + e.message);
      setTransProgress(0, "Failed");
      ui.btnTransRun.disabled = false;
      return;
    }

    const segmentMap = new Map();
    collectTextSegments(obj, segmentMap);
    const uniqueSegments = Array.from(segmentMap.keys());
    log(`Found ${uniqueSegments.length} unique text segments to translate.`, "INFO");

    if (!uniqueSegments.length) {
      const outStr = JSON.stringify(obj, null, 2);
      state.transOutputRaw = outStr;
      state.currentJsonForAssembly = outStr;
      ui.transOutputPreview.textContent = outStr;
      setTransProgress(100, "Nothing to translate");
      log("No translatable segments found; JSON left unchanged.", "WARN");
      return;
    }

    setTransProgress(30, "Requesting DeepL translation...");

    const srcLang = ui.deeplSource.value || '';
    const tgtLang = ui.deeplTarget.value || 'SV';
    const useProxy = document.getElementById('deeplCorsToggle').classList.contains('on');

    const translatedSegments = await translateSegmentsWithDeepL(
      key,
      uniqueSegments,
      srcLang,
      tgtLang,
      useProxy
    );

    if (translatedSegments.length !== uniqueSegments.length) {
      log("DeepL returned mismatched number of segments", "WARN");
    }

    uniqueSegments.forEach((seg, idx) => {
      segmentMap.set(seg, translatedSegments[idx] || seg);
    });

    setTransProgress(80, "Applying translations...");
    const translatedObj = applySegmentTranslations(obj, segmentMap);
    const outStr = JSON.stringify(translatedObj, null, 2);

    state.transOutputRaw = outStr;
    state.currentJsonForAssembly = outStr;

    ui.transOutputPreview.textContent = outStr;
    setTransProgress(100, "Translation complete");
    log("Translation step complete.", "SUCCESS");

  } catch(e) {
    log("Translation failed: " + e.message, "ERR");
    setTransProgress(0, "Failed");
    alert("Translation failed: " + e.message);
  } finally {
    ui.btnTransRun.disabled = false;
  }
}

/**
 * STEP 4: ASSEMBLY (IMPROVED CONTEXT-AWARE INJECTION & SANITIZATION)
 */
ui.btn3.addEventListener('click', async () => {
  const src = state.currentJsonForAssembly || state.groqJson;
  if (!src) {
    alert("No structured JSON available. Run Step 2 (Groq) or load/translate a JSON first.");
    return;
  }

  ui.btn3.disabled = true;
  setProgress(3, 10, "Parsing JSON...");

  try {
    let jsonObj = JSON.parse(src);
    const compress = document.getElementById('compressToggle').classList.contains('on');
    const quality = parseFloat(document.getElementById('imgQuality').value);
    const maxW = parseInt(document.getElementById('imgMaxWidth').value);
    const dispW = parseInt(document.getElementById('jsonDispWidth').value);
    const skipCount = parseInt(ui.skipImages.value) || 0;

    const usedImageIds = new Set();

    // Helper to check if a string is a placeholder
    const isPlaceholder = (str) => typeof str === 'string' && str.startsWith(CONFIG.phPrefix) && str.endsWith(CONFIG.phSuffix);
    
    // Helper to extract ID from placeholder
    const extractId = (ph) => ph.replace(CONFIG.phPrefix, '').replace(CONFIG.phSuffix, '').split('|')[0];

    // Recursive walker that is Context-Aware
    const processNode = async (node, parentKey = null) => {
      if (Array.isArray(node)) {
        const res = await Promise.all(node.map(item => processNode(item, parentKey)));
        return res;
      } 
      else if (typeof node === 'object' && node !== null) {
        const newObj = {};
        for (const [key, val] of Object.entries(node)) {
           newObj[key] = await processNode(val, key);
        }
        return newObj;
      }
      else if (typeof node === 'string') {
        if (isPlaceholder(node)) {
            const id = extractId(node);
            const asset = state.assets.find(a => a.id === id);
            if (asset) {
                usedImageIds.add(id);
                // ALWAYS compress/convert to JPEG to ensure manageable size
                const b64 = await compressImage(asset.blob, true, quality, maxW);
                
                // Context Check using parentKey
                const isSource = parentKey && ['src', 'url', 'href', 'data'].includes(parentKey.toLowerCase());
                
                if (isSource) {
                    return b64;
                } else {
                    return {
                        type: 'image',
                        src: b64,
                        width: asset.width,
                        description: '',
                        compressionImmune: false,
                        centering: 'default'
                    };
                }
            }
            // Asset not found? Return original string
            return node; 
        }
        return node;
      }
      return node;
    };

    setProgress(3, 30, "Processing Images...");
    let processedJson = await processNode(jsonObj);

    // FALLBACK: Inject unused images into Info.Images or Info.Bilder
    const validAssets = state.assets.slice(skipCount);
    const unusedAssets = validAssets.filter(a => !usedImageIds.has(a.id));
    
    if(unusedAssets.length > 0) {
      log(`Injecting ${unusedAssets.length} missing images into Info...`, "WARN");
      
      if(!processedJson.Info) processedJson.Info = {};
      
      let targetArray = null;
      if(Array.isArray(processedJson.Info.Images)) targetArray = processedJson.Info.Images;
      else if(Array.isArray(processedJson.Info.Bilder)) targetArray = processedJson.Info.Bilder;
      else {
        processedJson.Info.Images = [];
        targetArray = processedJson.Info.Images;
      }

      for(const asset of unusedAssets) {
        const b64 = await compressImage(asset.blob, true, quality, maxW);
        targetArray.push({
          type: 'image',
          src: b64,
          width: asset.width,
          description: '',
          compressionImmune: false,
          centering: 'default'
        });
      }
    }

    // --- STRICT SANITIZATION ---
    state.finalJson = sanitizeFinalJson(processedJson);
    
    const jsonStr = JSON.stringify(state.finalJson, null, 2);
    ui.finalOut.textContent = jsonStr;
    
    setProgress(3, 100, "Assembly Complete");
    log("Step 4 Complete", "SUCCESS");

  } catch(e) {
    log(e.message, "ERR");
    setProgress(3, 0, "Failed");
  } finally {
    ui.btn3.disabled = false;
  }
});

// --- Sanitizer Function ---
function sanitizeFinalJson(data) {
  if (!data || typeof data !== 'object') data = {};
  if (!data.quote) data.quote = {};
  
  // Helper to fix items array
  const fixItems = (arr) => {
    if (!Array.isArray(arr)) return [];
    // Filter out nulls and non-objects
    return arr.filter(i => i && typeof i === 'object').map(item => {
      // Fix subItems: Must be an array
      if (item.subItems && !Array.isArray(item.subItems)) {
        if (typeof item.subItems === 'object') item.subItems = [item.subItems];
        else item.subItems = [];
      }
      if (!item.subItems) item.subItems = [];
      return item;
    });
  };

  if (data.items) data.items = fixItems(data.items);
  else data.items = [];

  if (data.optionalItems) data.optionalItems = fixItems(data.optionalItems);
  else data.optionalItems = [];
  
  // Fix InfoImages
  if (data.infoImages && !Array.isArray(data.infoImages)) {
     if (typeof data.infoImages === 'object') data.infoImages = [data.infoImages];
     else data.infoImages = [];
  }
  if (data.infoImages) {
    data.infoImages = data.infoImages.filter(i => i && typeof i === 'object');
  } else {
    data.infoImages = [];
  }

  // Ensure Company Objects are Objects (not strings)
  if (data.companyA && typeof data.companyA !== 'object') data.companyA = { name: String(data.companyA) };
  if (data.companyB && typeof data.companyB !== 'object') data.companyB = { name: String(data.companyB) };

  return data;
}

// --- Image Compression ---
function compressImage(blob, doCompress, quality, maxWidth) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      if(!doCompress) return resolve(e.target.result);
      
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let w = img.width, h = img.height;
        if(w > maxWidth) {
          h = Math.round(h * (maxWidth/w));
          w = maxWidth;
        }
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#FFFFFF'; 
        ctx.fillRect(0,0,w,h);
        ctx.drawImage(img, 0, 0, w, h);
        resolve(canvas.toDataURL('image/jpeg', quality));
      };
      img.onerror = reject;
      img.src = e.target.result;
    };
    reader.readAsDataURL(blob);
  });
}

/**
 * UTILS
 */
window.copyToClip = (id) => {
  const txt = document.getElementById(id).textContent;
  navigator.clipboard.writeText(txt);
  log("Copied to clipboard");
};

ui.btnDl.addEventListener('click', () => {
  if(!state.finalJson) return;
  const blob = new Blob([JSON.stringify(state.finalJson, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  
  // Dynamic Filename
  let name = "output";
  if(state.file && state.file.name) {
    name = state.file.name.replace(/\.pdf$/i, "");
  }
  a.download = `${name} ocrd.json`;
  
  a.click();
});

// Download the JSON coming directly from the LLM (Step 2)
ui.btnDlGroq.addEventListener('click', () => {
  if(!state.groqJson) return;

  const pretty = prettyPrintJson(state.groqJson);

  const blob = new Blob([pretty], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;

  let name = "structured";
  if(state.file && state.file.name) {
    name = state.file.name.replace(/\.pdf$/i, "");
  }
  a.download = `${name} structured.json`;

  a.click();
});

// --- BTK Integration Logic ---

// Method 1: LocalStorage (Best for same domain)
ui.btnOpenBtkLocal.addEventListener('click', () => {
  if (!state.finalJson) return alert("No JSON generated yet. Run Step 4 first.");
  try {
    const id = crypto.randomUUID();
    const key = 'btk_quote_' + id;
    localStorage.setItem(key, JSON.stringify(state.finalJson));
    
    const btkUrl = CONFIG.btkUrl + '?quoteId=' + id;
    window.open(btkUrl, '_blank');
    log("Opened in BTK via LocalStorage", "SUCCESS");
  } catch (e) {
    log("Error saving to LocalStorage: " + e.message, "ERR");
    alert("Error saving to LocalStorage: " + e.message);
  }
});

// Method 2: Compressed URL Hash (Fallback / Sharing)
ui.btnOpenBtkUrl.addEventListener('click', () => {
  if (!state.finalJson) return alert("No JSON generated yet. Run Step 4 first.");
  try {
    const jsonStr = JSON.stringify(state.finalJson);
    // Pako deflate
    const compressed = pako.deflate(jsonStr);
    // Uint8Array to Binary String
    let binary = '';
    const len = compressed.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(compressed[i]);
    }
    // Base64
    const b64 = btoa(binary);
    const btkUrl = CONFIG.btkUrl + '#q=' + b64;
    
    // Check length limits
    if (btkUrl.length > 30000) {
      if(!confirm("The URL is very long (" + btkUrl.length + " chars). It might fail in some browsers. Continue?")) return;
    }
    window.open(btkUrl, '_blank');
    log("Opened in BTK via URL Hash", "SUCCESS");
  } catch (e) {
    log("Error compressing for URL: " + e.message, "ERR");
    alert("Error compressing for URL: " + e.message);
  }
});

// Cleanup
window.addEventListener('beforeunload', async ()=> {
  try{ if(state.ocrWorker){ await state.ocrWorker.terminate(); } } catch{}
});
</script>
</body>
</html>
